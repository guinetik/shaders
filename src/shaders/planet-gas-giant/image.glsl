/**
 * Gas Giant (Jupiter)
 * @author guinetik
 * @date 2025-11-27
 *
 * Jupiter-like gas giant with alternating tan zones and brown belts, turbulent
 * eddies at band boundaries, and the Great Red Spot. Fully procedural with no
 * texture dependencies.
 *
 * Based on the gas giant template by guinetik.
 *
 * Rendering layers (front to back):
 *   1. Banded atmosphere — alternating light zones and dark belts driven by
 *      sinusoidal latitude mapping with FBM turbulence at band edges
 *   2. Great Red Spot   — elliptical storm feature at ~22 deg S latitude with
 *      internal swirl pattern from polar-coordinate distortion
 *   3. Storm features   — small scattered bright spots from 1D FBM
 *   4. Specular + diffuse lighting with Blinn-Phong half-vector model
 *   5. Atmosphere limb  — Fresnel-like rim glow at the sphere edge
 *   6. Halo             — off-sphere atmospheric glow for background
 *
 * TECHNIQUE: Analytic unit-sphere projection. Same approach as the other planet
 * shaders: z derived from Pythagorean identity, giving position and normal.
 *
 * TECHNIQUE: Band-edge turbulence amplification. FBM turbulence is amplified at
 * band boundaries (detected via cos derivative of the band function) to simulate
 * the chaotic eddies that form at Jupiter's zone/belt interfaces.
 *
 * TECHNIQUE: Great Red Spot. An elliptical mask in latitude/longitude space is
 * combined with a swirl pattern generated by converting the local GRS coordinates
 * to polar angle + spiral offset. This creates the characteristic anti-cyclonic
 * vortex appearance.
 *
 * Noise: Hash-based 3D noise with a decorrelation matrix between FBM octaves,
 * identical to the Neptune-like shader. 5-octave 3D FBM for atmospheric bands
 * and 5-octave 1D FBM for storm features.
 */

const float tau = 6.283185;  // 2*PI — full circle in radians

// ── Jupiter color palette ────────────────────────────────────────────────────
#define ZONE_COLOR vec3(0.95, 0.75, 0.45)   // Light ammonia-ice zones — warm cream/tan
#define BELT_LIGHT vec3(0.82, 0.48, 0.20)   // Lighter brown belts — ammonium hydrosulfide
#define BELT_DARK vec3(0.60, 0.28, 0.10)    // Darker brown belts — deeper cloud deck
#define POLAR_COLOR vec3(0.50, 0.38, 0.28)  // Polar darkening — less reflective at high latitudes
#define GRS_COLOR vec3(0.78, 0.25, 0.10)    // Great Red Spot — phosphine/sulfur reddish tint

// ── Atmosphere ───────────────────────────────────────────────────────────────
#define ATMOS_COLOR vec3(0.90, 0.60, 0.30)  // Warm orange atmospheric glow and specular tint

// ── Band structure ───────────────────────────────────────────────────────────
#define BAND_COUNT 7.0           // Number of zone/belt pairs — higher = more/thinner bands.
                                 // Jupiter has ~6-8 major bands; 7.0 gives a good balance.
#define BAND_TURBULENCE 0.06     // FBM displacement of band latitude — higher = wavier edges.
                                 // Below 0.02: very clean stripes. Above 0.15: chaotic.
#define EDGE_TURBULENCE 0.15     // Extra turbulence at band boundaries — simulates the eddies
                                 // and vortex streets that form where zones meet belts.
                                 // Higher = more chaotic boundary layers.

// ── Great Red Spot ───────────────────────────────────────────────────────────
// Positioned at ~22 deg S latitude (Y ~ -0.37 on unit sphere)
#define GRS_LAT -0.37            // Latitude center — negative = southern hemisphere
#define GRS_LON 0.0              // Longitude center — 0.0 = centered on visible face at start
#define GRS_WIDTH 0.28           // Longitudinal half-width — wider = fatter storm ellipse
#define GRS_HEIGHT 0.14          // Latitudinal half-height — taller = more circular storm

// ── UV & lighting ──────────────────────────────────────────────────────────
#define BASE_UV_SCALE 1.1            // UV zoom — larger zooms out, showing more space around planet.
                                     // Automatically scaled up on portrait/mobile to prevent clipping.
#define LIGHT_DIR normalize(vec3(0.5, 1.0, 1.0))  // Sun direction (upper-right)
#define ROTATION_SPEED -0.1      // Planet spin rate — negative = eastward. Jupiter's ~10hr
                                 // rotation is the fastest in our solar system.

// =============================================================================
// HASH & NOISE
// =============================================================================
// Same hash-based value noise as the Neptune-like shader. PCG-style polynomial
// hashing avoids sin-based precision issues on some mobile GPUs.

float hash1(float p) {
    p = fract(p * 0.1031);
    p *= p + 33.33;
    p *= p + p;
    return fract(p);
}

vec3 hash3(vec3 p3) {
    p3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));
    p3 += dot(p3, p3.yxz + 33.33);
    return fract((p3.xxy + p3.yxx) * p3.zyx);
}

float noise1(float p) {
    float i = floor(p);
    float f = fract(p);
    float u = f * f * (3.0 - 2.0 * f);
    return 1.0 - 2.0 * mix(hash1(i), hash1(i + 1.0), u);
}

vec3 noise3(vec3 p) {
    vec3 i = floor(p);
    vec3 f = fract(p);
    vec3 u = f * f * (3.0 - 2.0 * f);
    return 1.0 - 2.0 * mix(
        mix(mix(hash3(i + vec3(0.0, 0.0, 0.0)),
                hash3(i + vec3(1.0, 0.0, 0.0)), u.x),
            mix(hash3(i + vec3(0.0, 1.0, 0.0)),
                hash3(i + vec3(1.0, 1.0, 0.0)), u.x), u.y),
        mix(mix(hash3(i + vec3(0.0, 0.0, 1.0)),
                hash3(i + vec3(1.0, 0.0, 1.0)), u.x),
            mix(hash3(i + vec3(0.0, 1.0, 1.0)),
                hash3(i + vec3(1.0, 1.0, 1.0)), u.x), u.y), u.z);
}

float fbm1(float p) {
    float f = noise1(p); p = 2.0 * p;
    f += 0.5 * noise1(p); p = 2.0 * p;
    f += 0.25 * noise1(p); p = 2.0 * p;
    f += 0.125 * noise1(p); p = 2.0 * p;
    f += 0.0625 * noise1(p);
    return f / 1.9375;
}

// Decorrelation matrix for 3D FBM — same as Neptune-like shader.
// Rotates domain between octaves to prevent axis-aligned grid artifacts.
const mat3 m = mat3(0.51162, -1.54702, 1.15972,
                    -1.70666, -0.92510, -0.48114,
                     0.90858, -0.86654, -1.55678);

vec3 fbm3(vec3 p) {
    vec3 f = noise3(p); p = m * p;
    f += 0.5 * noise3(p); p = m * p;
    f += 0.25 * noise3(p); p = m * p;
    f += 0.125 * noise3(p); p = m * p;
    f += 0.0625 * noise3(p);
    return f / 1.9375;
}

// =============================================================================
// UTILITY
// =============================================================================

vec2 Rotate(vec2 p, float a) {
    return p * cos(a) + vec2(-p.y, p.x) * sin(a);
}

// =============================================================================
// JUPITER BANDS
// =============================================================================

/**
 * Jupiter band color from latitude.
 * Alternating light zones and dark belts with smooth transitions.
 * Poles are darker and less saturated.
 */
vec3 bandColor(float lat, float lon) {
    // Polar darkening
    float polar = smoothstep(0.85, 1.0, abs(lat));

    // Alternating zones and belts
    float bandPos = lat * BAND_COUNT;
    float band = sin(bandPos * tau * 0.5);

    // Zone (light) vs belt (dark)
    vec3 zone = ZONE_COLOR;
    vec3 belt = mix(BELT_LIGHT, BELT_DARK, 0.5 + 0.5 * sin(bandPos * 1.7 + 2.0));
    vec3 col = mix(belt, zone, 0.5 + 0.5 * band);

    // Darken toward poles
    col = mix(col, POLAR_COLOR, polar);

    return col;
}

// =============================================================================
// MAIN
// =============================================================================

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    // Map window to -1..1, planet has r=1
    // Responsive UV scale: zoom out on portrait screens to keep planet fully visible
    float uvScale = BASE_UV_SCALE / min(1.0, iResolution.x / iResolution.y);
    vec2 uv = uvScale * (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;

    float z2 = 1.0 - uv.x * uv.x - uv.y * uv.y;
    if (z2 >= 0.0) {
        // Unit sphere
        vec3 pos = vec3(uv, sqrt(z2));
        vec3 normal = pos;

        // Auto rotation
        vec3 noisePos = pos;
        float surfaceRot = ROTATION_SPEED * iTime;
        noisePos.xz = Rotate(noisePos.xz, surfaceRot);

        // Latitude (-1 at pole, 0 equator, 1 at pole)
        float lat = noisePos.y;
        float lon = atan(noisePos.x, noisePos.z);

        // Turbulence displaces latitude for wavy band edges
        vec3 p = noisePos;
        vec3 turb = fbm3(12.0 * p);                            // 3-channel FBM for independent X/Y/Z turbulence
        float latDisplaced = lat + turb.x * BAND_TURBULENCE;   // Baseline latitude wobble

        // TECHNIQUE: Band-edge turbulence amplification — cos() derivative peaks
        // at band transitions (where sin() crosses zero). smoothstep isolates
        // only the sharpest transitions, then extra turbulence is added to
        // simulate the chaotic eddies at Jupiter's zone/belt interfaces.
        float bandEdge = abs(cos(lat * BAND_COUNT * tau * 0.5));
        bandEdge = smoothstep(0.85, 1.0, bandEdge);                  // Isolate sharp band boundaries
        latDisplaced += turb.y * EDGE_TURBULENCE * bandEdge;          // Extra chaos at boundaries only

        // Base band color
        vec3 color = bandColor(latDisplaced, lon);

        // Small-scale color variation from noise
        vec3 detail = fbm3(25.0 * vec3(0.3, 1.0, 0.3) * p);
        color += detail * 0.06;

        // ── Great Red Spot ──────────────────────────────────
        // TECHNIQUE: Elliptical mask in normalized lat/lon space. grsDist is the
        // squared distance in GRS-local coordinates; smoothstep gives soft edges.
        float grsLat = (lat - GRS_LAT) / GRS_HEIGHT;     // Normalize to ellipse half-height
        float grsLon = (lon - GRS_LON) / GRS_WIDTH;      // Normalize to ellipse half-width
        float grsDist = grsLat * grsLat + grsLon * grsLon; // Elliptical distance (1.0 = edge)
        float grsMask = smoothstep(1.0, 0.3, grsDist);   // Soft falloff — 0 outside, 1 at center

        // TECHNIQUE: Anti-cyclonic swirl pattern. Converting GRS-local coords to
        // polar angle + spiral offset (atan + sqrt*4) creates the characteristic
        // rotating vortex appearance of the Great Red Spot.
        float grsSwirl = atan(grsLat, grsLon) + sqrt(max(grsDist, 0.0)) * 4.0;  // Spiral factor 4.0 — tighter = more swirl arms
        float grsTexture = 0.5 + 0.5 * sin(grsSwirl * 3.0 + iTime * 0.3);       // 3 swirl arms, slow rotation
        vec3 grsCol = mix(GRS_COLOR, GRS_COLOR * 1.4, grsTexture * 0.3);         // Subtle brightness variation within spot

        color = mix(color, grsCol, grsMask);

        // ── Storm features ──────────────────────────────────
        float stormNoise = fbm1(10.0 * lat + 5.0);
        float storm = smoothstep(0.65, 0.85, stormNoise) * 0.15;
        color = mix(color, color * 1.3 + vec3(0.05, 0.03, 0.0), storm);

        // ── Lighting — Blinn-Phong with atmosphere-tinted specular ─────────
        float diffuse = 0.05 + clamp(dot(normal, LIGHT_DIR), 0.0, 1.0);   // 0.05 ambient floor
        vec3 lightViewHalf = normalize(LIGHT_DIR + vec3(0.0, 0.0, 1.0));  // Half-vector (view is +Z)
        float specular = 0.1 * pow(clamp(dot(normal, lightViewHalf), 0.0, 1.0), 30.0); // Exponent 30 = moderately tight highlight
        fragColor.rgb = diffuse * color * 2.0 + ATMOS_COLOR * specular;   // 2x boost for HDR vibrancy

        // Atmosphere limb
        vec3 atmosCol = ATMOS_COLOR * clamp(0.7 * diffuse + 0.05, 0.0, 1.0);
        fragColor.rgb = mix(fragColor.rgb, 0.5 * atmosCol, smoothstep(0.993, 1.0, length(uv)));
        fragColor.rgb += pow(1.0 - pos.z, 1.5) * atmosCol * 0.5;
    }
    // Off sphere — atmospheric halo
    else {
        float dist = length(uv);
        vec3 dir = normalize(vec3(uv, 1.0));
        float halo = smoothstep(1.3, 0.95, dist);
        float lightFacing = clamp(dot(dir, LIGHT_DIR), 0.0, 1.0);
        fragColor.rgb = ATMOS_COLOR * halo * lightFacing * 0.3;
    }

    // Gamma correction — standard sRGB approximation (1/2.2 ~ 0.45)
    // max() protects against negative values before pow()
    fragColor.rgb = pow(max(fragColor.rgb, vec3(0.0)), vec3(0.45));
    fragColor.a = 1.0;
}
