# Shader Gallery Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a static Shadertoy shader portfolio with Neutron UI aesthetic, multi-pass WebGL rendering, and build-time shader discovery.

**Architecture:** Vue 3 + TypeScript + Vite static site. A custom Vite plugin discovers shader folders at build time and generates a typed virtual module. Composables own all domain logic; Vue components are thin. Multi-pass WebGL2 renderer with FBO ping-ponging for buffer feedback.

**Tech Stack:** Vue 3, TypeScript (strict), Vite 6, Vue Router 4, Shiki, WebGL2

**Design doc:** `docs/plans/2026-02-12-shader-gallery-design.md`

**Reference for Neutron UI:** `D:\Developer\genuary2026\js\kernels\feynman\feynman.ui.js`

---

### Task 1: Project Scaffolding

**Files:**
- Create: `package.json`
- Create: `tsconfig.json`
- Create: `tsconfig.node.json`
- Create: `vite.config.ts`
- Create: `index.html`
- Create: `src/main.ts`
- Create: `src/App.vue`
- Create: `.gitignore`

**Step 1: Scaffold Vite + Vue 3 + TypeScript project**

Run:
```bash
cd D:/Developer/shaders
npm create vite@latest . -- --template vue-ts
```

If prompted about non-empty directory, confirm overwrite (only `docs/` exists).

**Step 2: Install dependencies**

Run:
```bash
npm install
npm install vue-router@4 shiki
```

**Step 3: Verify the scaffold works**

Run:
```bash
npm run dev
```

Expected: Dev server starts, default Vite+Vue page loads at localhost.

Stop the dev server (Ctrl+C).

**Step 4: Enable strict TypeScript**

Modify `tsconfig.json` — ensure these compiler options are set:
```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true
  }
}
```

**Step 5: Clean up scaffold boilerplate**

- Delete `src/components/HelloWorld.vue`
- Delete `src/assets/vue.svg`
- Delete `public/vite.svg`
- Clear `src/style.css` contents (we'll replace with Neutron theme)
- Simplify `src/App.vue` to just `<router-view />`

**Step 6: Verify clean build**

Run:
```bash
npm run build
```

Expected: Build succeeds with no errors.

**Step 7: Commit**

```bash
git add -A
git commit -m "feat: scaffold Vite + Vue 3 + TypeScript project"
```

---

### Task 2: Types & Constants

**Files:**
- Create: `src/types.ts`
- Create: `src/constants.ts`

**Step 1: Create the type definitions**

Create `src/types.ts` with all TSDoc-annotated interfaces from the design doc:

```ts
/**
 * Shader Gallery — Core Type Definitions
 *
 * All public interfaces for the shader gallery application.
 * See docs/plans/2026-02-12-shader-gallery-design.md for full spec.
 *
 * @module types
 */

/** Supported external links for a shader entry */
export interface ShaderLinks {
  /** URL to the shader on Shadertoy */
  shadertoy?: string;
  /** URL to the shader on ShaderKit */
  shaderkit?: string;
}

/** Channel binding target for multi-pass shaders */
export type ChannelTarget = 'buffer-a' | 'buffer-b' | 'buffer-c' | 'buffer-d' | 'self';

/** Uniform channel slot names matching Shadertoy convention */
export type ChannelSlot = 'iChannel0' | 'iChannel1' | 'iChannel2' | 'iChannel3';

/** Channel bindings for a single render pass */
export type ChannelBindings = Partial<Record<ChannelSlot, ChannelTarget>>;

/** Render pass identifiers */
export type PassId = 'image' | 'bufferA' | 'bufferB' | 'bufferC' | 'bufferD';

/** Channel configuration for all passes in a shader */
export type ShaderChannels = Partial<Record<PassId, ChannelBindings>>;

/** Shader source code organized by render pass */
export interface ShaderPasses {
  /** Main output pass (always present) */
  image: string;
  /** Buffer A source (optional) */
  bufferA?: string;
  /** Buffer B source (optional) */
  bufferB?: string;
  /** Buffer C source (optional) */
  bufferC?: string;
  /** Buffer D source (optional) */
  bufferD?: string;
}

/** Metadata for a single shader in the gallery */
export interface ShaderMeta {
  /** URL-friendly identifier, derived from folder name */
  slug: string;
  /** Display title */
  title: string;
  /** Brief description of the shader effect */
  description: string;
  /** ISO 8601 date string (YYYY-MM-DD) */
  date: string;
  /** Categorization tags (e.g., "raymarching", "noise") */
  tags: string[];
  /** External links to shader platforms */
  links: ShaderLinks;
}

/** Complete shader entry as generated by the Vite plugin */
export interface ShaderEntry extends ShaderMeta {
  /** Path to the screenshot image */
  screenshotUrl: string;
  /** GLSL source code per render pass */
  passes: ShaderPasses;
  /** Channel wiring between passes */
  channels: ShaderChannels;
}

/** Raw meta.json structure before slug/screenshot are injected */
export interface RawShaderMeta {
  /** Display title */
  title: string;
  /** Brief description of the shader effect */
  description: string;
  /** ISO 8601 date string (YYYY-MM-DD) */
  date: string;
  /** Categorization tags */
  tags: string[];
  /** External links */
  links: ShaderLinks;
  /** Optional channel wiring overrides */
  channels?: ShaderChannels;
}
```

**Step 2: Create named constants**

Create `src/constants.ts`:

```ts
/**
 * Application-wide named constants.
 * No magic numbers — every literal value lives here.
 *
 * @module constants
 */

// -- Layout --

/** Number of gallery columns on mobile viewports */
export const GALLERY_COLUMNS_MOBILE = 1;

/** Number of gallery columns on tablet viewports (>=768px) */
export const GALLERY_COLUMNS_TABLET = 2;

/** Number of gallery columns on desktop viewports (>=1024px) */
export const GALLERY_COLUMNS_DESKTOP = 3;

/** Breakpoint for tablet layout in pixels */
export const BREAKPOINT_TABLET = 768;

/** Breakpoint for desktop layout in pixels */
export const BREAKPOINT_DESKTOP = 1024;

/** Minimum touch target size in pixels (WCAG) */
export const MIN_TOUCH_TARGET_PX = 44;

// -- Spacing Scale (px) --

export const SPACING_XS = 4;
export const SPACING_SM = 8;
export const SPACING_MD = 12;
export const SPACING_LG = 16;
export const SPACING_XL = 24;

// -- Font Sizes (px) --

export const FONT_SIZE_XS = 10;
export const FONT_SIZE_SM = 12;
export const FONT_SIZE_BASE = 14;
export const FONT_SIZE_LG = 18;
export const FONT_SIZE_XL = 24;

// -- WebGL --

/** Default frames per second target for shader rendering */
export const SHADER_TARGET_FPS = 60;

/** Maximum number of buffer passes (A through D) */
export const MAX_BUFFER_PASSES = 4;

/** Number of FBOs per buffer for ping-pong feedback */
export const FBOS_PER_BUFFER = 2;

// -- Shader Discovery --

/** Required file name for the main output pass */
export const IMAGE_PASS_FILENAME = 'image.glsl';

/** Ordered buffer file names for discovery */
export const BUFFER_FILENAMES = [
  'buffer-a.glsl',
  'buffer-b.glsl',
  'buffer-c.glsl',
  'buffer-d.glsl',
] as const;

/** Metadata file name in each shader folder */
export const META_FILENAME = 'meta.json';

/** Screenshot path pattern (relative to /public) */
export const SCREENSHOT_PATH_PREFIX = '/shaders/';

/** Screenshot file name */
export const SCREENSHOT_FILENAME = 'screenshot.png';
```

**Step 3: Verify types compile**

Run:
```bash
npx vue-tsc --noEmit
```

Expected: No errors.

**Step 4: Commit**

```bash
git add src/types.ts src/constants.ts
git commit -m "feat: add core type definitions and named constants"
```

---

### Task 3: Neutron UI Theme

**Files:**
- Create: `src/theme/neutron-theme.ts`
- Create: `src/assets/neutron.css`

**Step 1: Create typed theme constants**

Create `src/theme/neutron-theme.ts`:

```ts
/**
 * Neutron UI Theme — Typed Constants
 *
 * Ported from the NeutronTheme system in feynman.ui.js.
 * Oscilloscope / particle detector aesthetic: dark blue-black
 * backgrounds, cyan glows, Fira Code monospace.
 *
 * @module theme/neutron-theme
 */

/** Available Neutron UI color variant names */
export type NeutronVariant = 'cyan' | 'danger' | 'magenta' | 'yellow' | 'green';

/** Color token set for a single Neutron UI variant */
export interface NeutronColorSet {
  readonly primary: string;
  readonly glow: string;
  readonly glowStrong: string;
  readonly bg: string;
  readonly bgLight: string;
  readonly bgHover: string;
  readonly border: string;
  readonly borderActive: string;
  readonly text: string;
  readonly textDim: string;
  readonly textWhite: string;
}

/** Complete Neutron UI color palette */
export const NEUTRON_COLORS: Readonly<Record<NeutronVariant, NeutronColorSet>> = {
  cyan: {
    primary: '#0ff',
    glow: 'rgba(0, 200, 255, 0.4)',
    glowStrong: 'rgba(0, 200, 255, 0.8)',
    bg: 'rgba(0, 5, 10, 0.95)',
    bgLight: 'rgba(0, 10, 20, 0.9)',
    bgHover: 'rgba(0, 200, 255, 0.15)',
    border: 'rgba(0, 200, 255, 0.4)',
    borderActive: '#0ff',
    text: '#0ff',
    textDim: 'rgba(0, 200, 255, 0.5)',
    textWhite: '#fff',
  },
  danger: {
    primary: '#f50',
    glow: 'rgba(255, 50, 50, 0.4)',
    glowStrong: 'rgba(255, 50, 50, 0.8)',
    bg: 'rgba(20, 0, 0, 0.95)',
    bgLight: 'rgba(40, 5, 5, 0.9)',
    bgHover: 'rgba(255, 100, 50, 0.15)',
    border: 'rgba(255, 100, 50, 0.5)',
    borderActive: '#f50',
    text: '#f90',
    textDim: 'rgba(255, 150, 100, 0.7)',
    textWhite: 'rgba(255, 200, 180, 0.9)',
  },
  magenta: {
    primary: '#f0f',
    glow: 'rgba(255, 50, 255, 0.4)',
    glowStrong: 'rgba(255, 100, 255, 0.8)',
    bg: 'rgba(15, 0, 15, 0.95)',
    bgLight: 'rgba(25, 5, 25, 0.9)',
    bgHover: 'rgba(255, 100, 255, 0.15)',
    border: 'rgba(255, 100, 255, 0.4)',
    borderActive: '#f0f',
    text: '#f6f',
    textDim: 'rgba(255, 150, 255, 0.6)',
    textWhite: '#fff',
  },
  yellow: {
    primary: '#ff0',
    glow: 'rgba(255, 255, 50, 0.4)',
    glowStrong: 'rgba(255, 255, 100, 0.8)',
    bg: 'rgba(15, 15, 0, 0.95)',
    bgLight: 'rgba(25, 25, 5, 0.9)',
    bgHover: 'rgba(255, 255, 100, 0.15)',
    border: 'rgba(255, 255, 100, 0.4)',
    borderActive: '#ff0',
    text: '#ff8',
    textDim: 'rgba(255, 255, 150, 0.6)',
    textWhite: '#fff',
  },
  green: {
    primary: '#0f0',
    glow: 'rgba(50, 255, 50, 0.4)',
    glowStrong: 'rgba(100, 255, 100, 0.8)',
    bg: 'rgba(0, 15, 5, 0.95)',
    bgLight: 'rgba(5, 25, 10, 0.9)',
    bgHover: 'rgba(100, 255, 100, 0.15)',
    border: 'rgba(100, 255, 100, 0.4)',
    borderActive: '#0f0',
    text: '#8f8',
    textDim: 'rgba(150, 255, 150, 0.6)',
    textWhite: '#fff',
  },
} as const;

/** Neutron UI font family constant */
export const NEUTRON_FONT_FAMILY = '"Fira Code", monospace';
```

**Step 2: Create the CSS theme file**

Create `src/assets/neutron.css` with CSS custom properties derived from the theme constants, global reset, Fira Code import, and base body styles. Use the cyan variant values for all `--n-*` custom properties. Include:

- Google Fonts import for Fira Code (weights 400, 700)
- CSS reset (`*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }`)
- Body: `background: #0a0a0f; color: #e0e0e8; font-family: "Fira Code", monospace;`
- All `--n-*` custom properties on `:root` matching the cyan color set
- Variant classes `.neutron-magenta`, `.neutron-yellow`, `.neutron-green`, `.neutron-danger` that override the `--n-*` variables

**Step 3: Import the CSS in main.ts**

Add `import './assets/neutron.css'` to `src/main.ts`.

**Step 4: Verify build**

Run:
```bash
npm run build
```

Expected: Build succeeds.

**Step 5: Commit**

```bash
git add src/theme/ src/assets/neutron.css src/main.ts
git commit -m "feat: add Neutron UI theme system with typed constants and CSS"
```

---

### Task 4: Router Setup

**Files:**
- Create: `src/router.ts`
- Create: `src/views/GalleryView.vue` (placeholder)
- Create: `src/views/ShaderDetailView.vue` (placeholder)
- Modify: `src/main.ts`
- Modify: `src/App.vue`

**Step 1: Create placeholder views**

Create `src/views/GalleryView.vue`:
```vue
<template>
  <div class="gallery-view">
    <h1>Shader Gallery</h1>
  </div>
</template>
```

Create `src/views/ShaderDetailView.vue`:
```vue
<template>
  <div class="shader-detail-view">
    <h1>Shader: {{ $route.params.slug }}</h1>
  </div>
</template>
```

**Step 2: Create the router**

Create `src/router.ts`:
```ts
/**
 * Vue Router configuration.
 * Hash mode for static hosting compatibility (GitHub Pages).
 *
 * @module router
 */
import { createRouter, createWebHashHistory } from 'vue-router';
import type { RouteRecordRaw } from 'vue-router';
import GalleryView from './views/GalleryView.vue';

const routes: RouteRecordRaw[] = [
  {
    path: '/',
    name: 'gallery',
    component: GalleryView,
  },
  {
    path: '/shader/:slug',
    name: 'shader-detail',
    component: () => import('./views/ShaderDetailView.vue'),
  },
];

const router = createRouter({
  history: createWebHashHistory(),
  routes,
});

export default router;
```

**Step 3: Wire router into main.ts and App.vue**

Update `src/main.ts` to import and use the router.
Update `src/App.vue` to contain only `<router-view />`.

**Step 4: Verify routing works**

Run:
```bash
npm run dev
```

- Visit `http://localhost:5173/` — should show "Shader Gallery"
- Visit `http://localhost:5173/#/shader/test` — should show "Shader: test"

Stop dev server.

**Step 5: Verify build**

Run:
```bash
npm run build
```

Expected: Build succeeds.

**Step 6: Commit**

```bash
git add src/router.ts src/views/ src/main.ts src/App.vue
git commit -m "feat: add Vue Router with gallery and detail routes"
```

---

### Task 5: Vite Shader Loader Plugin

**Files:**
- Create: `src/plugins/shaderLoader.ts`
- Create: `src/shaders/test-gradient/meta.json` (test fixture)
- Create: `src/shaders/test-gradient/image.glsl` (test fixture)
- Create: `public/shaders/test-gradient/screenshot.png` (placeholder)
- Modify: `vite.config.ts`

**Step 1: Create a test shader fixture**

Create `src/shaders/test-gradient/meta.json`:
```json
{
  "title": "Test Gradient",
  "description": "A simple gradient for testing the build pipeline.",
  "date": "2026-01-01",
  "tags": ["test"],
  "links": {}
}
```

Create `src/shaders/test-gradient/image.glsl`:
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    fragColor = vec4(uv, 0.5 + 0.5 * sin(iTime), 1.0);
}
```

Create a 1x1 placeholder PNG at `public/shaders/test-gradient/screenshot.png` (can be any small PNG).

**Step 2: Create the Vite plugin**

Create `src/plugins/shaderLoader.ts`. This is a Vite plugin that:

1. Defines a virtual module ID: `virtual:shader-registry`
2. In `resolveId`, intercepts the virtual module
3. In `load`, scans `src/shaders/*/` directories
4. For each folder: reads `meta.json`, reads `image.glsl` and any `buffer-*.glsl` files
5. Assembles `ShaderEntry[]` and returns it as a `export const shaders = [...]` module
6. Uses the constants `IMAGE_PASS_FILENAME`, `BUFFER_FILENAMES`, `META_FILENAME`, `SCREENSHOT_PATH_PREFIX`, `SCREENSHOT_FILENAME`
7. Applies default channel wiring: `image.iChannel0 = buffer-a` if buffer-a exists, buffers get `iChannel0 = self`
8. Merges any explicit `channels` from `meta.json` over defaults

Key implementation detail: use `fs.readdirSync` and `fs.readFileSync` since this runs at build time in Node.

**Step 3: Create the type declaration for the virtual module**

Create `src/shader-registry.d.ts`:
```ts
declare module 'virtual:shader-registry' {
  import type { ShaderEntry } from './types';
  export const shaders: ShaderEntry[];
}
```

**Step 4: Register the plugin in vite.config.ts**

```ts
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
import { shaderLoaderPlugin } from './src/plugins/shaderLoader';

export default defineConfig({
  plugins: [shaderLoaderPlugin(), vue()],
});
```

**Step 5: Verify the plugin works**

Create a temporary test file `src/test-registry.ts`:
```ts
import { shaders } from 'virtual:shader-registry';
console.log(JSON.stringify(shaders, null, 2));
```

Import it in `main.ts` temporarily and run:
```bash
npm run dev
```

Check browser console — should print the test-gradient shader entry with slug, title, passes.image containing the GLSL source, and default channel wiring.

Remove the temporary test import from `main.ts`.

**Step 6: Verify build**

Run:
```bash
npm run build
```

Expected: Build succeeds, virtual module is resolved.

**Step 7: Commit**

```bash
git add src/plugins/ src/shaders/test-gradient/ public/shaders/test-gradient/ src/shader-registry.d.ts vite.config.ts
git commit -m "feat: add Vite shader loader plugin with build-time discovery"
```

---

### Task 6: Shader Registry Service

**Files:**
- Create: `src/services/shaderRegistry.ts`

**Step 1: Create the registry service**

Create `src/services/shaderRegistry.ts`:

```ts
/**
 * Shader Registry — Typed access to the build-time shader manifest.
 *
 * Wraps the virtual:shader-registry module with lookup helpers.
 *
 * @module services/shaderRegistry
 */
import { shaders } from 'virtual:shader-registry';
import type { ShaderEntry } from '../types';

/** All shader entries, sorted by date descending (newest first) */
export const allShaders: readonly ShaderEntry[] = [...shaders].sort(
  (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()
);

/** All unique tags across all shaders, sorted alphabetically */
export const allTags: readonly string[] = [
  ...new Set(shaders.flatMap((s) => s.tags)),
].sort();

/**
 * Find a shader entry by its slug.
 *
 * @param slug - The URL-friendly identifier
 * @returns The matching shader entry, or undefined if not found
 */
export function findShaderBySlug(slug: string): ShaderEntry | undefined {
  return allShaders.find((s) => s.slug === slug);
}
```

**Step 2: Verify build**

Run:
```bash
npm run build
```

Expected: Build succeeds.

**Step 3: Commit**

```bash
git add src/services/shaderRegistry.ts
git commit -m "feat: add shader registry service with typed lookups"
```

---

### Task 7: Gallery Composable & View

**Files:**
- Create: `src/composables/useShaderGallery.ts`
- Create: `src/components/TagFilter.vue`
- Create: `src/components/ShaderCard.vue`
- Modify: `src/views/GalleryView.vue`

**Step 1: Create the gallery composable**

Create `src/composables/useShaderGallery.ts`:

```ts
/**
 * Gallery Composable — Filtering and sorting logic for the shader grid.
 *
 * Owns: active tag filter, filtered shader list.
 * Vue components bind to the returned reactive state.
 *
 * @module composables/useShaderGallery
 */
import { ref, computed } from 'vue';
import { allShaders, allTags } from '../services/shaderRegistry';
import type { ShaderEntry } from '../types';

/**
 * Provides reactive gallery state: tag filtering and sorted shader list.
 *
 * @returns Reactive refs and computed properties for gallery rendering
 */
export function useShaderGallery() {
  /** Currently selected tag filter, or null for "all" */
  const activeTag = ref<string | null>(null);

  /** Shaders filtered by the active tag */
  const filteredShaders = computed<readonly ShaderEntry[]>(() => {
    if (activeTag.value === null) {
      return allShaders;
    }
    return allShaders.filter((s) => s.tags.includes(activeTag.value!));
  });

  /**
   * Set the active tag filter.
   * Pass null to clear the filter and show all shaders.
   *
   * @param tag - Tag to filter by, or null for all
   */
  function setTag(tag: string | null): void {
    activeTag.value = activeTag.value === tag ? null : tag;
  }

  return {
    activeTag,
    allTags,
    filteredShaders,
    setTag,
  };
}
```

**Step 2: Create TagFilter component**

Create `src/components/TagFilter.vue`:

A thin component that renders a row of tag pill buttons. Props: `tags: string[]`, `activeTag: string | null`. Emits: `select(tag: string | null)`.

Style: Neutron UI pill buttons using CSS custom properties. Active pill gets `--n-border-active` border and `--n-bg-hover` background. Each pill is minimum `MIN_TOUCH_TARGET_PX` height. Use Fira Code font. Mobile-first: horizontal scroll on overflow.

**Step 3: Create ShaderCard component**

Create `src/components/ShaderCard.vue`:

Props: `shader: ShaderEntry`. The card is a `<router-link>` to `/shader/:slug`.

Layout:
- Dark panel (`--n-bg`) with `--n-border` border, `border-radius: 4px`
- Screenshot `<img>` fills the card body
- Title overlay at bottom: `--n-bg` backdrop with `--n-text-white` text
- Tags row below title (small pills, variant colors)
- Hover: border brightens to `--n-border-active`, add `box-shadow` glow

**Step 4: Build the GalleryView**

Replace `src/views/GalleryView.vue`:

Uses `useShaderGallery()`. Template contains:
- `<TagFilter>` at top
- CSS grid of `<ShaderCard>` components
- Grid: `grid-template-columns: 1fr` by default, `repeat(2, 1fr)` at tablet, `repeat(3, 1fr)` at desktop
- Gap: `SPACING_LG`

The view is thin — all logic is in the composable.

**Step 5: Verify the gallery renders**

Run:
```bash
npm run dev
```

Visit `http://localhost:5173/` — should see the tag filter bar with "test" tag and one shader card for "Test Gradient".

**Step 6: Commit**

```bash
git add src/composables/useShaderGallery.ts src/components/TagFilter.vue src/components/ShaderCard.vue src/views/GalleryView.vue
git commit -m "feat: add gallery view with tag filtering and shader cards"
```

---

### Task 8: WebGL Shader Renderer Composable

**Files:**
- Create: `src/composables/useShaderRenderer.ts`

This is the most complex piece. The composable:

**Step 1: Create the composable skeleton**

Create `src/composables/useShaderRenderer.ts` with TSDoc and the public API:

```ts
/**
 * Shader Renderer Composable — WebGL2 multi-pass rendering pipeline.
 *
 * Manages: WebGL2 context creation, shader compilation, FBO allocation
 * for buffer ping-ponging, render loop with requestAnimationFrame,
 * Shadertoy-compatible uniforms, and resource cleanup.
 *
 * @module composables/useShaderRenderer
 */
```

Public API:
```ts
export function useShaderRenderer(
  canvasRef: Ref<HTMLCanvasElement | null>,
  passes: ShaderPasses,
  channels: ShaderChannels
): {
  /** Error message if shader compilation fails */
  error: Ref<string | null>;
  /** Whether the renderer is currently running */
  isRunning: Ref<boolean>;
  /** Start the render loop */
  start: () => void;
  /** Stop the render loop */
  stop: () => void;
}
```

**Step 2: Implement WebGL2 context + single-pass rendering**

Start with single-pass (image-only) rendering:

1. On `canvasRef` becoming non-null (use `watch`), create WebGL2 context
2. Create a fullscreen quad (two triangles)
3. Standard vertex shader (pass-through UV)
4. Compile the `passes.image` fragment shader with a Shadertoy-compatible wrapper:
   - Prepend `#version 300 es` and precision qualifiers
   - Add uniform declarations: `iTime`, `iResolution`, `iMouse`, `iFrame`, `iChannel0`-`iChannel3`
   - Wrap `mainImage` call in a `void main()` that calls it
5. Set up `requestAnimationFrame` loop updating uniforms each frame
6. Pause on `document.visibilitychange` (hidden)
7. Clean up on component unmount (`onUnmounted`)

If compilation fails, capture the error log into the `error` ref instead of crashing.

**Step 3: Add multi-pass FBO pipeline**

Extend the composable:

1. For each buffer pass present in `passes`, create a shader program
2. Allocate two FBOs per buffer (ping-pong for self-feedback)
3. Render loop order: Buffer A -> B -> C -> D -> Image
4. Before each pass, bind input textures according to `channels` config
5. After each buffer pass, swap its ping-pong FBOs
6. Image pass renders to the default framebuffer (screen)

Use named constants: `MAX_BUFFER_PASSES`, `FBOS_PER_BUFFER`.

**Step 4: Verify with the test-gradient shader**

Temporarily add a `<canvas>` to the detail view and wire up the composable with the test-gradient shader. Run dev server and navigate to `/shader/test-gradient` — should see a color gradient animating over time.

**Step 5: Commit**

```bash
git add src/composables/useShaderRenderer.ts
git commit -m "feat: add WebGL2 multi-pass shader renderer composable"
```

---

### Task 9: Code Viewer Component

**Files:**
- Create: `src/components/CodeViewer.vue`
- Create: `src/composables/useCodeHighlighter.ts`

**Step 1: Create the highlighting composable**

Create `src/composables/useCodeHighlighter.ts`:

```ts
/**
 * Code Highlighter Composable — Shiki-based GLSL syntax highlighting.
 *
 * Lazily loads the Shiki highlighter on first use.
 * Returns highlighted HTML for a given GLSL source string.
 *
 * @module composables/useCodeHighlighter
 */
```

- Uses Shiki's `createHighlighter` with a dark theme (e.g., `vitesse-dark` or custom Neutron theme)
- Loads the `glsl` language
- Returns a `highlight(code: string): Promise<string>` function and an `isReady` ref
- The highlighter instance is created once (module-level singleton)

**Step 2: Create the CodeViewer component**

Create `src/components/CodeViewer.vue`:

Props: `passes: ShaderPasses`

Layout:
- If multiple passes exist, show sub-tabs: "Image", "Buffer A", etc.
- Tab bar styled as Neutron toggle buttons
- Code area: dark Neutron panel (`--n-bg`), left cyan accent bar (3px)
- Content: `v-html` of the Shiki-highlighted code
- Line numbers in `--n-text-dim`
- Scroll: `overflow-y: auto` with styled scrollbar (thin, cyan)

The component is thin — it calls `useCodeHighlighter()` and renders the result.

**Step 3: Verify highlighting works**

Temporarily render `<CodeViewer>` with the test-gradient image.glsl source. Run dev server — should show syntax-highlighted GLSL.

**Step 4: Commit**

```bash
git add src/composables/useCodeHighlighter.ts src/components/CodeViewer.vue
git commit -m "feat: add GLSL code viewer with Shiki syntax highlighting"
```

---

### Task 10: Shader Detail View

**Files:**
- Create: `src/composables/useShaderDetail.ts`
- Create: `src/components/ShaderRenderer.vue`
- Modify: `src/views/ShaderDetailView.vue`

**Step 1: Create the detail composable**

Create `src/composables/useShaderDetail.ts`:

```ts
/**
 * Shader Detail Composable — Loads a single shader by slug.
 *
 * Resolves the shader entry from the registry and provides
 * reactive state for the detail view.
 *
 * @module composables/useShaderDetail
 */
```

- Takes a `slug: string` parameter (from route params)
- Looks up the shader via `findShaderBySlug`
- Returns: `shader: Ref<ShaderEntry | undefined>`, `notFound: Ref<boolean>`
- Also manages the active tab state: `activeTab: Ref<'render' | 'code'>`

**Step 2: Create the ShaderRenderer component (thin wrapper)**

Create `src/components/ShaderRenderer.vue`:

Props: `passes: ShaderPasses`, `channels: ShaderChannels`

Template: just a `<canvas ref="canvasRef">` element, full-width.

Script: calls `useShaderRenderer(canvasRef, props.passes, props.channels)`. Exposes the `error` ref for the parent to display if needed. That's it — the component is thin.

**Step 3: Build the ShaderDetailView**

Replace `src/views/ShaderDetailView.vue`:

Uses `useShaderDetail(route.params.slug)`.

Layout (mobile-first):
- Back button (router-link to `/`) at top-left, Neutron-styled
- Toggle tab bar: "Render" | "Code" buttons, Neutron UI toggle style
- When `activeTab === 'render'`: `<ShaderRenderer>`
- When `activeTab === 'code'`: `<CodeViewer>`
- Below: shader metadata section:
  - Title (`--n-text-white`, `FONT_SIZE_XL`)
  - Description (`--n-text-dim`)
  - Date
  - Tag pills (reuse from gallery styling)
  - External link buttons (Shadertoy, ShaderKit) — Neutron-styled anchor buttons with glow on hover
- If `notFound`: show a "Shader not found" message

**Step 4: Verify end-to-end flow**

Run:
```bash
npm run dev
```

1. Visit `/` — see gallery with test-gradient card
2. Click card — navigate to `/shader/test-gradient`
3. See live shader rendering on "Render" tab
4. Toggle to "Code" — see highlighted GLSL
5. See metadata (title, description, date, tags)
6. Click back — return to gallery

**Step 5: Commit**

```bash
git add src/composables/useShaderDetail.ts src/components/ShaderRenderer.vue src/views/ShaderDetailView.vue
git commit -m "feat: add shader detail view with render/code toggle"
```

---

### Task 11: Mobile-First Responsive Polish

**Files:**
- Modify: `src/assets/neutron.css`
- Modify: `src/components/ShaderCard.vue`
- Modify: `src/components/TagFilter.vue`
- Modify: `src/views/GalleryView.vue`
- Modify: `src/views/ShaderDetailView.vue`

**Step 1: Add responsive media queries**

In `neutron.css`, add media query breakpoints using the named constants:
- `@media (min-width: 768px)` — tablet adjustments
- `@media (min-width: 1024px)` — desktop adjustments

**Step 2: Polish gallery grid**

Ensure the grid in `GalleryView.vue` uses:
- `grid-template-columns: 1fr` at mobile
- `repeat(2, 1fr)` at tablet
- `repeat(3, 1fr)` at desktop
- Appropriate `gap` and `padding`

**Step 3: Polish tag filter**

Ensure `TagFilter.vue`:
- Horizontal scroll on mobile (`overflow-x: auto`, `flex-wrap: nowrap`)
- Wraps on desktop (`flex-wrap: wrap`)
- All pills meet `MIN_TOUCH_TARGET_PX` height

**Step 4: Polish detail view**

Ensure `ShaderDetailView.vue`:
- Toggle tabs are full-width on mobile
- Canvas fills available width
- Metadata section has comfortable padding on mobile
- External link buttons meet touch target minimum

**Step 5: Visual review on mobile viewport**

Run dev server, open Chrome DevTools, toggle device toolbar. Check:
- iPhone SE (375px) — single column, readable, no overflow
- iPad (768px) — two columns
- Desktop (1024px+) — three columns
- All touch targets >= 44px

**Step 6: Commit**

```bash
git add src/assets/neutron.css src/components/ src/views/
git commit -m "feat: mobile-first responsive polish for all views"
```

---

### Task 12: Production Build & Static Deploy Config

**Files:**
- Modify: `vite.config.ts`
- Modify: `package.json`

**Step 1: Configure base URL for GitHub Pages**

In `vite.config.ts`, add `base: '/shaders/'` (matches the repo name for GitHub Pages).

**Step 2: Add deploy script**

In `package.json`, add a build script that outputs to `dist/`:
```json
{
  "scripts": {
    "build": "vue-tsc --noEmit && vite build",
    "preview": "vite preview"
  }
}
```

**Step 3: Verify production build**

Run:
```bash
npm run build && npm run preview
```

Visit the preview URL. Verify:
- Gallery loads with cards
- Navigation to detail works
- Shader renders in WebGL
- Code viewer highlights correctly
- All assets load (screenshots, fonts)

**Step 4: Commit**

```bash
git add vite.config.ts package.json
git commit -m "feat: configure production build for GitHub Pages deployment"
```

---

### Task 13: Remove Test Fixture, Prep for Real Shaders

**Step 1: Keep test-gradient as a working example**

The test-gradient shader serves as documentation for the shader folder convention. Rename it to something more useful or keep it — user's choice.

**Step 2: Final build verification**

Run:
```bash
npm run build
```

Expected: Clean build, no warnings, no errors.

**Step 3: Final commit**

```bash
git add -A
git commit -m "feat: shader gallery complete, ready for shader content"
```

---

## Summary

| Task | What | Key Files |
|------|------|-----------|
| 1 | Project scaffolding | `package.json`, `vite.config.ts`, scaffold |
| 2 | Types & constants | `src/types.ts`, `src/constants.ts` |
| 3 | Neutron UI theme | `src/theme/neutron-theme.ts`, `src/assets/neutron.css` |
| 4 | Router setup | `src/router.ts`, placeholder views |
| 5 | Vite shader loader plugin | `src/plugins/shaderLoader.ts`, test fixture |
| 6 | Shader registry service | `src/services/shaderRegistry.ts` |
| 7 | Gallery composable & view | composable, TagFilter, ShaderCard, GalleryView |
| 8 | WebGL renderer composable | `src/composables/useShaderRenderer.ts` |
| 9 | Code viewer | `src/composables/useCodeHighlighter.ts`, CodeViewer |
| 10 | Shader detail view | composable, ShaderRenderer, ShaderDetailView |
| 11 | Mobile responsive polish | CSS + component tweaks |
| 12 | Production build config | vite.config.ts, deploy scripts |
| 13 | Final cleanup | Remove test fixture, final verify |
